// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tml.proto

#include "tml.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace onnxruntime {
namespace proto {
PROTOBUF_CONSTEXPR MapStringToString_VEntry_DoNotUse::MapStringToString_VEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct MapStringToString_VEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapStringToString_VEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapStringToString_VEntry_DoNotUseDefaultTypeInternal() {}
  union {
    MapStringToString_VEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapStringToString_VEntry_DoNotUseDefaultTypeInternal _MapStringToString_VEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR MapStringToString::MapStringToString(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MapStringToStringDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapStringToStringDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapStringToStringDefaultTypeInternal() {}
  union {
    MapStringToString _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapStringToStringDefaultTypeInternal _MapStringToString_default_instance_;
PROTOBUF_CONSTEXPR MapStringToInt64_VEntry_DoNotUse::MapStringToInt64_VEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct MapStringToInt64_VEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapStringToInt64_VEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapStringToInt64_VEntry_DoNotUseDefaultTypeInternal() {}
  union {
    MapStringToInt64_VEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapStringToInt64_VEntry_DoNotUseDefaultTypeInternal _MapStringToInt64_VEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR MapStringToInt64::MapStringToInt64(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MapStringToInt64DefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapStringToInt64DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapStringToInt64DefaultTypeInternal() {}
  union {
    MapStringToInt64 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapStringToInt64DefaultTypeInternal _MapStringToInt64_default_instance_;
PROTOBUF_CONSTEXPR MapStringToDouble_VEntry_DoNotUse::MapStringToDouble_VEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct MapStringToDouble_VEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapStringToDouble_VEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapStringToDouble_VEntry_DoNotUseDefaultTypeInternal() {}
  union {
    MapStringToDouble_VEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapStringToDouble_VEntry_DoNotUseDefaultTypeInternal _MapStringToDouble_VEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR MapStringToDouble::MapStringToDouble(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MapStringToDoubleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapStringToDoubleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapStringToDoubleDefaultTypeInternal() {}
  union {
    MapStringToDouble _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapStringToDoubleDefaultTypeInternal _MapStringToDouble_default_instance_;
PROTOBUF_CONSTEXPR MapStringToFloat_VEntry_DoNotUse::MapStringToFloat_VEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct MapStringToFloat_VEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapStringToFloat_VEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapStringToFloat_VEntry_DoNotUseDefaultTypeInternal() {}
  union {
    MapStringToFloat_VEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapStringToFloat_VEntry_DoNotUseDefaultTypeInternal _MapStringToFloat_VEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR MapStringToFloat::MapStringToFloat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MapStringToFloatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapStringToFloatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapStringToFloatDefaultTypeInternal() {}
  union {
    MapStringToFloat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapStringToFloatDefaultTypeInternal _MapStringToFloat_default_instance_;
PROTOBUF_CONSTEXPR MapInt64ToString_VEntry_DoNotUse::MapInt64ToString_VEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct MapInt64ToString_VEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapInt64ToString_VEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapInt64ToString_VEntry_DoNotUseDefaultTypeInternal() {}
  union {
    MapInt64ToString_VEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapInt64ToString_VEntry_DoNotUseDefaultTypeInternal _MapInt64ToString_VEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR MapInt64ToString::MapInt64ToString(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MapInt64ToStringDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapInt64ToStringDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapInt64ToStringDefaultTypeInternal() {}
  union {
    MapInt64ToString _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapInt64ToStringDefaultTypeInternal _MapInt64ToString_default_instance_;
PROTOBUF_CONSTEXPR MapInt64ToInt64_VEntry_DoNotUse::MapInt64ToInt64_VEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct MapInt64ToInt64_VEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapInt64ToInt64_VEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapInt64ToInt64_VEntry_DoNotUseDefaultTypeInternal() {}
  union {
    MapInt64ToInt64_VEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapInt64ToInt64_VEntry_DoNotUseDefaultTypeInternal _MapInt64ToInt64_VEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR MapInt64ToInt64::MapInt64ToInt64(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MapInt64ToInt64DefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapInt64ToInt64DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapInt64ToInt64DefaultTypeInternal() {}
  union {
    MapInt64ToInt64 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapInt64ToInt64DefaultTypeInternal _MapInt64ToInt64_default_instance_;
PROTOBUF_CONSTEXPR MapInt64ToFloat_VEntry_DoNotUse::MapInt64ToFloat_VEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct MapInt64ToFloat_VEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapInt64ToFloat_VEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapInt64ToFloat_VEntry_DoNotUseDefaultTypeInternal() {}
  union {
    MapInt64ToFloat_VEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapInt64ToFloat_VEntry_DoNotUseDefaultTypeInternal _MapInt64ToFloat_VEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR MapInt64ToFloat::MapInt64ToFloat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MapInt64ToFloatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapInt64ToFloatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapInt64ToFloatDefaultTypeInternal() {}
  union {
    MapInt64ToFloat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapInt64ToFloatDefaultTypeInternal _MapInt64ToFloat_default_instance_;
PROTOBUF_CONSTEXPR MapInt64ToDouble_VEntry_DoNotUse::MapInt64ToDouble_VEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct MapInt64ToDouble_VEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapInt64ToDouble_VEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapInt64ToDouble_VEntry_DoNotUseDefaultTypeInternal() {}
  union {
    MapInt64ToDouble_VEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapInt64ToDouble_VEntry_DoNotUseDefaultTypeInternal _MapInt64ToDouble_VEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR MapInt64ToDouble::MapInt64ToDouble(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MapInt64ToDoubleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapInt64ToDoubleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapInt64ToDoubleDefaultTypeInternal() {}
  union {
    MapInt64ToDouble _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapInt64ToDoubleDefaultTypeInternal _MapInt64ToDouble_default_instance_;
PROTOBUF_CONSTEXPR VectorString::VectorString(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VectorStringDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorStringDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorStringDefaultTypeInternal() {}
  union {
    VectorString _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorStringDefaultTypeInternal _VectorString_default_instance_;
PROTOBUF_CONSTEXPR VectorFloat::VectorFloat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VectorFloatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorFloatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorFloatDefaultTypeInternal() {}
  union {
    VectorFloat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorFloatDefaultTypeInternal _VectorFloat_default_instance_;
PROTOBUF_CONSTEXPR VectorInt64::VectorInt64(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VectorInt64DefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorInt64DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorInt64DefaultTypeInternal() {}
  union {
    VectorInt64 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorInt64DefaultTypeInternal _VectorInt64_default_instance_;
PROTOBUF_CONSTEXPR VectorDouble::VectorDouble(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VectorDoubleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorDoubleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorDoubleDefaultTypeInternal() {}
  union {
    VectorDouble _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorDoubleDefaultTypeInternal _VectorDouble_default_instance_;
PROTOBUF_CONSTEXPR VectorMapStringToFloat::VectorMapStringToFloat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VectorMapStringToFloatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorMapStringToFloatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorMapStringToFloatDefaultTypeInternal() {}
  union {
    VectorMapStringToFloat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorMapStringToFloatDefaultTypeInternal _VectorMapStringToFloat_default_instance_;
PROTOBUF_CONSTEXPR VectorMapInt64ToFloat::VectorMapInt64ToFloat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VectorMapInt64ToFloatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorMapInt64ToFloatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorMapInt64ToFloatDefaultTypeInternal() {}
  union {
    VectorMapInt64ToFloat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorMapInt64ToFloatDefaultTypeInternal _VectorMapInt64ToFloat_default_instance_;
PROTOBUF_CONSTEXPR TraditionalMLData::TraditionalMLData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.debug_info_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.values_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TraditionalMLDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TraditionalMLDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TraditionalMLDataDefaultTypeInternal() {}
  union {
    TraditionalMLData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TraditionalMLDataDefaultTypeInternal _TraditionalMLData_default_instance_;
PROTOBUF_CONSTEXPR TestCaseConfig::TestCaseConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.per_sample_tolerance_)*/0
  , /*decltype(_impl_.relative_per_sample_tolerance_)*/0
  , /*decltype(_impl_.post_processing_)*/false} {}
struct TestCaseConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TestCaseConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TestCaseConfigDefaultTypeInternal() {}
  union {
    TestCaseConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TestCaseConfigDefaultTypeInternal _TestCaseConfig_default_instance_;
}  // namespace proto
}  // namespace onnxruntime
namespace onnxruntime {
namespace proto {

// ===================================================================

MapStringToString_VEntry_DoNotUse::MapStringToString_VEntry_DoNotUse() {}
MapStringToString_VEntry_DoNotUse::MapStringToString_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void MapStringToString_VEntry_DoNotUse::MergeFrom(const MapStringToString_VEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class MapStringToString::_Internal {
 public:
};

MapStringToString::MapStringToString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.MapStringToString)
}
MapStringToString::MapStringToString(const MapStringToString& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MapStringToString* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.MapStringToString)
}

inline void MapStringToString::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MapStringToString::~MapStringToString() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.MapStringToString)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MapStringToString::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v_.Destruct();
  _impl_.v_.~MapFieldLite();
}

void MapStringToString::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MapStringToString::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.MapStringToString)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.v_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MapStringToString::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, string> v = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.v_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MapStringToString::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.MapStringToString)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, string> v = 1;
  if (!this->_internal_v().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = MapStringToString_VEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_v();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.MapStringToString)
  return target;
}

size_t MapStringToString::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.MapStringToString)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> v = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_v_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_v().begin();
      it != this->_internal_v().end(); ++it) {
    total_size += MapStringToString_VEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MapStringToString::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MapStringToString*>(
      &from));
}

void MapStringToString::MergeFrom(const MapStringToString& from) {
  MapStringToString* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.MapStringToString)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MapStringToString::CopyFrom(const MapStringToString& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.MapStringToString)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapStringToString::IsInitialized() const {
  return true;
}

void MapStringToString::InternalSwap(MapStringToString* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.v_.InternalSwap(&other->_impl_.v_);
}

std::string MapStringToString::GetTypeName() const {
  return "onnxruntime.proto.MapStringToString";
}


// ===================================================================

MapStringToInt64_VEntry_DoNotUse::MapStringToInt64_VEntry_DoNotUse() {}
MapStringToInt64_VEntry_DoNotUse::MapStringToInt64_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void MapStringToInt64_VEntry_DoNotUse::MergeFrom(const MapStringToInt64_VEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class MapStringToInt64::_Internal {
 public:
};

MapStringToInt64::MapStringToInt64(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.MapStringToInt64)
}
MapStringToInt64::MapStringToInt64(const MapStringToInt64& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MapStringToInt64* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.MapStringToInt64)
}

inline void MapStringToInt64::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MapStringToInt64::~MapStringToInt64() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.MapStringToInt64)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MapStringToInt64::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v_.Destruct();
  _impl_.v_.~MapFieldLite();
}

void MapStringToInt64::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MapStringToInt64::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.MapStringToInt64)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.v_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MapStringToInt64::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, int64> v = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.v_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MapStringToInt64::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.MapStringToInt64)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, int64> v = 1;
  if (!this->_internal_v().empty()) {
    using MapType = ::_pb::Map<std::string, int64_t>;
    using WireHelper = MapStringToInt64_VEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_v();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.MapStringToInt64)
  return target;
}

size_t MapStringToInt64::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.MapStringToInt64)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, int64> v = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_v_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >::const_iterator
      it = this->_internal_v().begin();
      it != this->_internal_v().end(); ++it) {
    total_size += MapStringToInt64_VEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MapStringToInt64::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MapStringToInt64*>(
      &from));
}

void MapStringToInt64::MergeFrom(const MapStringToInt64& from) {
  MapStringToInt64* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.MapStringToInt64)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MapStringToInt64::CopyFrom(const MapStringToInt64& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.MapStringToInt64)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapStringToInt64::IsInitialized() const {
  return true;
}

void MapStringToInt64::InternalSwap(MapStringToInt64* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.v_.InternalSwap(&other->_impl_.v_);
}

std::string MapStringToInt64::GetTypeName() const {
  return "onnxruntime.proto.MapStringToInt64";
}


// ===================================================================

MapStringToDouble_VEntry_DoNotUse::MapStringToDouble_VEntry_DoNotUse() {}
MapStringToDouble_VEntry_DoNotUse::MapStringToDouble_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void MapStringToDouble_VEntry_DoNotUse::MergeFrom(const MapStringToDouble_VEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class MapStringToDouble::_Internal {
 public:
};

MapStringToDouble::MapStringToDouble(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.MapStringToDouble)
}
MapStringToDouble::MapStringToDouble(const MapStringToDouble& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MapStringToDouble* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.MapStringToDouble)
}

inline void MapStringToDouble::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MapStringToDouble::~MapStringToDouble() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.MapStringToDouble)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MapStringToDouble::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v_.Destruct();
  _impl_.v_.~MapFieldLite();
}

void MapStringToDouble::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MapStringToDouble::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.MapStringToDouble)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.v_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MapStringToDouble::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, double> v = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.v_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MapStringToDouble::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.MapStringToDouble)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, double> v = 1;
  if (!this->_internal_v().empty()) {
    using MapType = ::_pb::Map<std::string, double>;
    using WireHelper = MapStringToDouble_VEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_v();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.MapStringToDouble)
  return target;
}

size_t MapStringToDouble::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.MapStringToDouble)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, double> v = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_v_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_v().begin();
      it != this->_internal_v().end(); ++it) {
    total_size += MapStringToDouble_VEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MapStringToDouble::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MapStringToDouble*>(
      &from));
}

void MapStringToDouble::MergeFrom(const MapStringToDouble& from) {
  MapStringToDouble* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.MapStringToDouble)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MapStringToDouble::CopyFrom(const MapStringToDouble& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.MapStringToDouble)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapStringToDouble::IsInitialized() const {
  return true;
}

void MapStringToDouble::InternalSwap(MapStringToDouble* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.v_.InternalSwap(&other->_impl_.v_);
}

std::string MapStringToDouble::GetTypeName() const {
  return "onnxruntime.proto.MapStringToDouble";
}


// ===================================================================

MapStringToFloat_VEntry_DoNotUse::MapStringToFloat_VEntry_DoNotUse() {}
MapStringToFloat_VEntry_DoNotUse::MapStringToFloat_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void MapStringToFloat_VEntry_DoNotUse::MergeFrom(const MapStringToFloat_VEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class MapStringToFloat::_Internal {
 public:
};

MapStringToFloat::MapStringToFloat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.MapStringToFloat)
}
MapStringToFloat::MapStringToFloat(const MapStringToFloat& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MapStringToFloat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.MapStringToFloat)
}

inline void MapStringToFloat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MapStringToFloat::~MapStringToFloat() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.MapStringToFloat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MapStringToFloat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v_.Destruct();
  _impl_.v_.~MapFieldLite();
}

void MapStringToFloat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MapStringToFloat::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.MapStringToFloat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.v_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MapStringToFloat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, float> v = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.v_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MapStringToFloat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.MapStringToFloat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, float> v = 1;
  if (!this->_internal_v().empty()) {
    using MapType = ::_pb::Map<std::string, float>;
    using WireHelper = MapStringToFloat_VEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_v();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.MapStringToFloat)
  return target;
}

size_t MapStringToFloat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.MapStringToFloat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, float> v = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_v_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, float >::const_iterator
      it = this->_internal_v().begin();
      it != this->_internal_v().end(); ++it) {
    total_size += MapStringToFloat_VEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MapStringToFloat::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MapStringToFloat*>(
      &from));
}

void MapStringToFloat::MergeFrom(const MapStringToFloat& from) {
  MapStringToFloat* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.MapStringToFloat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MapStringToFloat::CopyFrom(const MapStringToFloat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.MapStringToFloat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapStringToFloat::IsInitialized() const {
  return true;
}

void MapStringToFloat::InternalSwap(MapStringToFloat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.v_.InternalSwap(&other->_impl_.v_);
}

std::string MapStringToFloat::GetTypeName() const {
  return "onnxruntime.proto.MapStringToFloat";
}


// ===================================================================

MapInt64ToString_VEntry_DoNotUse::MapInt64ToString_VEntry_DoNotUse() {}
MapInt64ToString_VEntry_DoNotUse::MapInt64ToString_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void MapInt64ToString_VEntry_DoNotUse::MergeFrom(const MapInt64ToString_VEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class MapInt64ToString::_Internal {
 public:
};

MapInt64ToString::MapInt64ToString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.MapInt64ToString)
}
MapInt64ToString::MapInt64ToString(const MapInt64ToString& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MapInt64ToString* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.MapInt64ToString)
}

inline void MapInt64ToString::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MapInt64ToString::~MapInt64ToString() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.MapInt64ToString)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MapInt64ToString::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v_.Destruct();
  _impl_.v_.~MapFieldLite();
}

void MapInt64ToString::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MapInt64ToString::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.MapInt64ToString)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.v_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MapInt64ToString::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<int64, string> v = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.v_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MapInt64ToString::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.MapInt64ToString)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<int64, string> v = 1;
  if (!this->_internal_v().empty()) {
    using MapType = ::_pb::Map<int64_t, std::string>;
    using WireHelper = MapInt64ToString_VEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_v();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.MapInt64ToString)
  return target;
}

size_t MapInt64ToString::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.MapInt64ToString)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int64, string> v = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_v_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int64_t, std::string >::const_iterator
      it = this->_internal_v().begin();
      it != this->_internal_v().end(); ++it) {
    total_size += MapInt64ToString_VEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MapInt64ToString::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MapInt64ToString*>(
      &from));
}

void MapInt64ToString::MergeFrom(const MapInt64ToString& from) {
  MapInt64ToString* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.MapInt64ToString)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MapInt64ToString::CopyFrom(const MapInt64ToString& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.MapInt64ToString)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapInt64ToString::IsInitialized() const {
  return true;
}

void MapInt64ToString::InternalSwap(MapInt64ToString* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.v_.InternalSwap(&other->_impl_.v_);
}

std::string MapInt64ToString::GetTypeName() const {
  return "onnxruntime.proto.MapInt64ToString";
}


// ===================================================================

MapInt64ToInt64_VEntry_DoNotUse::MapInt64ToInt64_VEntry_DoNotUse() {}
MapInt64ToInt64_VEntry_DoNotUse::MapInt64ToInt64_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void MapInt64ToInt64_VEntry_DoNotUse::MergeFrom(const MapInt64ToInt64_VEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class MapInt64ToInt64::_Internal {
 public:
};

MapInt64ToInt64::MapInt64ToInt64(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.MapInt64ToInt64)
}
MapInt64ToInt64::MapInt64ToInt64(const MapInt64ToInt64& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MapInt64ToInt64* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.MapInt64ToInt64)
}

inline void MapInt64ToInt64::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MapInt64ToInt64::~MapInt64ToInt64() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.MapInt64ToInt64)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MapInt64ToInt64::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v_.Destruct();
  _impl_.v_.~MapFieldLite();
}

void MapInt64ToInt64::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MapInt64ToInt64::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.MapInt64ToInt64)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.v_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MapInt64ToInt64::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<int64, int64> v = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.v_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MapInt64ToInt64::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.MapInt64ToInt64)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<int64, int64> v = 1;
  if (!this->_internal_v().empty()) {
    using MapType = ::_pb::Map<int64_t, int64_t>;
    using WireHelper = MapInt64ToInt64_VEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_v();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.MapInt64ToInt64)
  return target;
}

size_t MapInt64ToInt64::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.MapInt64ToInt64)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int64, int64> v = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_v_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >::const_iterator
      it = this->_internal_v().begin();
      it != this->_internal_v().end(); ++it) {
    total_size += MapInt64ToInt64_VEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MapInt64ToInt64::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MapInt64ToInt64*>(
      &from));
}

void MapInt64ToInt64::MergeFrom(const MapInt64ToInt64& from) {
  MapInt64ToInt64* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.MapInt64ToInt64)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MapInt64ToInt64::CopyFrom(const MapInt64ToInt64& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.MapInt64ToInt64)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapInt64ToInt64::IsInitialized() const {
  return true;
}

void MapInt64ToInt64::InternalSwap(MapInt64ToInt64* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.v_.InternalSwap(&other->_impl_.v_);
}

std::string MapInt64ToInt64::GetTypeName() const {
  return "onnxruntime.proto.MapInt64ToInt64";
}


// ===================================================================

MapInt64ToFloat_VEntry_DoNotUse::MapInt64ToFloat_VEntry_DoNotUse() {}
MapInt64ToFloat_VEntry_DoNotUse::MapInt64ToFloat_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void MapInt64ToFloat_VEntry_DoNotUse::MergeFrom(const MapInt64ToFloat_VEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class MapInt64ToFloat::_Internal {
 public:
};

MapInt64ToFloat::MapInt64ToFloat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.MapInt64ToFloat)
}
MapInt64ToFloat::MapInt64ToFloat(const MapInt64ToFloat& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MapInt64ToFloat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.MapInt64ToFloat)
}

inline void MapInt64ToFloat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MapInt64ToFloat::~MapInt64ToFloat() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.MapInt64ToFloat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MapInt64ToFloat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v_.Destruct();
  _impl_.v_.~MapFieldLite();
}

void MapInt64ToFloat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MapInt64ToFloat::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.MapInt64ToFloat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.v_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MapInt64ToFloat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<int64, float> v = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.v_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MapInt64ToFloat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.MapInt64ToFloat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<int64, float> v = 1;
  if (!this->_internal_v().empty()) {
    using MapType = ::_pb::Map<int64_t, float>;
    using WireHelper = MapInt64ToFloat_VEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_v();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.MapInt64ToFloat)
  return target;
}

size_t MapInt64ToFloat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.MapInt64ToFloat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int64, float> v = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_v_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int64_t, float >::const_iterator
      it = this->_internal_v().begin();
      it != this->_internal_v().end(); ++it) {
    total_size += MapInt64ToFloat_VEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MapInt64ToFloat::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MapInt64ToFloat*>(
      &from));
}

void MapInt64ToFloat::MergeFrom(const MapInt64ToFloat& from) {
  MapInt64ToFloat* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.MapInt64ToFloat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MapInt64ToFloat::CopyFrom(const MapInt64ToFloat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.MapInt64ToFloat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapInt64ToFloat::IsInitialized() const {
  return true;
}

void MapInt64ToFloat::InternalSwap(MapInt64ToFloat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.v_.InternalSwap(&other->_impl_.v_);
}

std::string MapInt64ToFloat::GetTypeName() const {
  return "onnxruntime.proto.MapInt64ToFloat";
}


// ===================================================================

MapInt64ToDouble_VEntry_DoNotUse::MapInt64ToDouble_VEntry_DoNotUse() {}
MapInt64ToDouble_VEntry_DoNotUse::MapInt64ToDouble_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void MapInt64ToDouble_VEntry_DoNotUse::MergeFrom(const MapInt64ToDouble_VEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class MapInt64ToDouble::_Internal {
 public:
};

MapInt64ToDouble::MapInt64ToDouble(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.MapInt64ToDouble)
}
MapInt64ToDouble::MapInt64ToDouble(const MapInt64ToDouble& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MapInt64ToDouble* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.MapInt64ToDouble)
}

inline void MapInt64ToDouble::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.v_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MapInt64ToDouble::~MapInt64ToDouble() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.MapInt64ToDouble)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MapInt64ToDouble::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v_.Destruct();
  _impl_.v_.~MapFieldLite();
}

void MapInt64ToDouble::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MapInt64ToDouble::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.MapInt64ToDouble)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.v_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MapInt64ToDouble::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<int64, double> v = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.v_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MapInt64ToDouble::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.MapInt64ToDouble)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<int64, double> v = 1;
  if (!this->_internal_v().empty()) {
    using MapType = ::_pb::Map<int64_t, double>;
    using WireHelper = MapInt64ToDouble_VEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_v();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.MapInt64ToDouble)
  return target;
}

size_t MapInt64ToDouble::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.MapInt64ToDouble)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int64, double> v = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_v_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int64_t, double >::const_iterator
      it = this->_internal_v().begin();
      it != this->_internal_v().end(); ++it) {
    total_size += MapInt64ToDouble_VEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MapInt64ToDouble::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MapInt64ToDouble*>(
      &from));
}

void MapInt64ToDouble::MergeFrom(const MapInt64ToDouble& from) {
  MapInt64ToDouble* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.MapInt64ToDouble)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MapInt64ToDouble::CopyFrom(const MapInt64ToDouble& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.MapInt64ToDouble)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapInt64ToDouble::IsInitialized() const {
  return true;
}

void MapInt64ToDouble::InternalSwap(MapInt64ToDouble* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.v_.InternalSwap(&other->_impl_.v_);
}

std::string MapInt64ToDouble::GetTypeName() const {
  return "onnxruntime.proto.MapInt64ToDouble";
}


// ===================================================================

class VectorString::_Internal {
 public:
};

VectorString::VectorString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.VectorString)
}
VectorString::VectorString(const VectorString& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  VectorString* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.v_){from._impl_.v_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.VectorString)
}

inline void VectorString::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.v_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VectorString::~VectorString() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.VectorString)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VectorString::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v_.~RepeatedPtrField();
}

void VectorString::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VectorString::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.VectorString)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.v_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VectorString::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string v = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_v();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VectorString::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.VectorString)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string v = 1;
  for (int i = 0, n = this->_internal_v_size(); i < n; i++) {
    const auto& s = this->_internal_v(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.VectorString)
  return target;
}

size_t VectorString::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.VectorString)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string v = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.v_.size());
  for (int i = 0, n = _impl_.v_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.v_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VectorString::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VectorString*>(
      &from));
}

void VectorString::MergeFrom(const VectorString& from) {
  VectorString* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.VectorString)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VectorString::CopyFrom(const VectorString& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.VectorString)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorString::IsInitialized() const {
  return true;
}

void VectorString::InternalSwap(VectorString* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.v_.InternalSwap(&other->_impl_.v_);
}

std::string VectorString::GetTypeName() const {
  return "onnxruntime.proto.VectorString";
}


// ===================================================================

class VectorFloat::_Internal {
 public:
};

VectorFloat::VectorFloat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.VectorFloat)
}
VectorFloat::VectorFloat(const VectorFloat& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  VectorFloat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.v_){from._impl_.v_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.VectorFloat)
}

inline void VectorFloat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.v_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VectorFloat::~VectorFloat() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.VectorFloat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VectorFloat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v_.~RepeatedField();
}

void VectorFloat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VectorFloat::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.VectorFloat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.v_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VectorFloat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float v = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_v(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<13>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_v(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VectorFloat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.VectorFloat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float v = 1;
  for (int i = 0, n = this->_internal_v_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_v(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.VectorFloat)
  return target;
}

size_t VectorFloat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.VectorFloat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float v = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_v_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_v_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VectorFloat::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VectorFloat*>(
      &from));
}

void VectorFloat::MergeFrom(const VectorFloat& from) {
  VectorFloat* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.VectorFloat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VectorFloat::CopyFrom(const VectorFloat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.VectorFloat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorFloat::IsInitialized() const {
  return true;
}

void VectorFloat::InternalSwap(VectorFloat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.v_.InternalSwap(&other->_impl_.v_);
}

std::string VectorFloat::GetTypeName() const {
  return "onnxruntime.proto.VectorFloat";
}


// ===================================================================

class VectorInt64::_Internal {
 public:
};

VectorInt64::VectorInt64(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.VectorInt64)
}
VectorInt64::VectorInt64(const VectorInt64& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  VectorInt64* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.v_){from._impl_.v_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.VectorInt64)
}

inline void VectorInt64::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.v_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VectorInt64::~VectorInt64() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.VectorInt64)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VectorInt64::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v_.~RepeatedField();
}

void VectorInt64::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VectorInt64::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.VectorInt64)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.v_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VectorInt64::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 v = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_v(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_v(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VectorInt64::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.VectorInt64)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 v = 1;
  for (int i = 0, n = this->_internal_v_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_v(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.VectorInt64)
  return target;
}

size_t VectorInt64::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.VectorInt64)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 v = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.v_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_v_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VectorInt64::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VectorInt64*>(
      &from));
}

void VectorInt64::MergeFrom(const VectorInt64& from) {
  VectorInt64* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.VectorInt64)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VectorInt64::CopyFrom(const VectorInt64& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.VectorInt64)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorInt64::IsInitialized() const {
  return true;
}

void VectorInt64::InternalSwap(VectorInt64* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.v_.InternalSwap(&other->_impl_.v_);
}

std::string VectorInt64::GetTypeName() const {
  return "onnxruntime.proto.VectorInt64";
}


// ===================================================================

class VectorDouble::_Internal {
 public:
};

VectorDouble::VectorDouble(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.VectorDouble)
}
VectorDouble::VectorDouble(const VectorDouble& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  VectorDouble* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.v_){from._impl_.v_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.VectorDouble)
}

inline void VectorDouble::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.v_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VectorDouble::~VectorDouble() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.VectorDouble)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VectorDouble::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v_.~RepeatedField();
}

void VectorDouble::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VectorDouble::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.VectorDouble)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.v_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VectorDouble::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated double v = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_v(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<9>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_v(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VectorDouble::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.VectorDouble)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double v = 1;
  for (int i = 0, n = this->_internal_v_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_v(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.VectorDouble)
  return target;
}

size_t VectorDouble::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.VectorDouble)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double v = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_v_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_v_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VectorDouble::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VectorDouble*>(
      &from));
}

void VectorDouble::MergeFrom(const VectorDouble& from) {
  VectorDouble* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.VectorDouble)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VectorDouble::CopyFrom(const VectorDouble& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.VectorDouble)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorDouble::IsInitialized() const {
  return true;
}

void VectorDouble::InternalSwap(VectorDouble* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.v_.InternalSwap(&other->_impl_.v_);
}

std::string VectorDouble::GetTypeName() const {
  return "onnxruntime.proto.VectorDouble";
}


// ===================================================================

class VectorMapStringToFloat::_Internal {
 public:
};

VectorMapStringToFloat::VectorMapStringToFloat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.VectorMapStringToFloat)
}
VectorMapStringToFloat::VectorMapStringToFloat(const VectorMapStringToFloat& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  VectorMapStringToFloat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.v_){from._impl_.v_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.VectorMapStringToFloat)
}

inline void VectorMapStringToFloat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.v_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VectorMapStringToFloat::~VectorMapStringToFloat() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.VectorMapStringToFloat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VectorMapStringToFloat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v_.~RepeatedPtrField();
}

void VectorMapStringToFloat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VectorMapStringToFloat::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.VectorMapStringToFloat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.v_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VectorMapStringToFloat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .onnxruntime.proto.MapStringToFloat v = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_v(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VectorMapStringToFloat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.VectorMapStringToFloat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .onnxruntime.proto.MapStringToFloat v = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_v_size()); i < n; i++) {
    const auto& repfield = this->_internal_v(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.VectorMapStringToFloat)
  return target;
}

size_t VectorMapStringToFloat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.VectorMapStringToFloat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .onnxruntime.proto.MapStringToFloat v = 1;
  total_size += 1UL * this->_internal_v_size();
  for (const auto& msg : this->_impl_.v_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VectorMapStringToFloat::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VectorMapStringToFloat*>(
      &from));
}

void VectorMapStringToFloat::MergeFrom(const VectorMapStringToFloat& from) {
  VectorMapStringToFloat* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.VectorMapStringToFloat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VectorMapStringToFloat::CopyFrom(const VectorMapStringToFloat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.VectorMapStringToFloat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorMapStringToFloat::IsInitialized() const {
  return true;
}

void VectorMapStringToFloat::InternalSwap(VectorMapStringToFloat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.v_.InternalSwap(&other->_impl_.v_);
}

std::string VectorMapStringToFloat::GetTypeName() const {
  return "onnxruntime.proto.VectorMapStringToFloat";
}


// ===================================================================

class VectorMapInt64ToFloat::_Internal {
 public:
};

VectorMapInt64ToFloat::VectorMapInt64ToFloat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.VectorMapInt64ToFloat)
}
VectorMapInt64ToFloat::VectorMapInt64ToFloat(const VectorMapInt64ToFloat& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  VectorMapInt64ToFloat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.v_){from._impl_.v_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.VectorMapInt64ToFloat)
}

inline void VectorMapInt64ToFloat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.v_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VectorMapInt64ToFloat::~VectorMapInt64ToFloat() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.VectorMapInt64ToFloat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VectorMapInt64ToFloat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v_.~RepeatedPtrField();
}

void VectorMapInt64ToFloat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VectorMapInt64ToFloat::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.VectorMapInt64ToFloat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.v_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VectorMapInt64ToFloat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .onnxruntime.proto.MapInt64ToFloat v = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_v(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VectorMapInt64ToFloat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.VectorMapInt64ToFloat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .onnxruntime.proto.MapInt64ToFloat v = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_v_size()); i < n; i++) {
    const auto& repfield = this->_internal_v(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.VectorMapInt64ToFloat)
  return target;
}

size_t VectorMapInt64ToFloat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.VectorMapInt64ToFloat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .onnxruntime.proto.MapInt64ToFloat v = 1;
  total_size += 1UL * this->_internal_v_size();
  for (const auto& msg : this->_impl_.v_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VectorMapInt64ToFloat::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VectorMapInt64ToFloat*>(
      &from));
}

void VectorMapInt64ToFloat::MergeFrom(const VectorMapInt64ToFloat& from) {
  VectorMapInt64ToFloat* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.VectorMapInt64ToFloat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.v_.MergeFrom(from._impl_.v_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VectorMapInt64ToFloat::CopyFrom(const VectorMapInt64ToFloat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.VectorMapInt64ToFloat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorMapInt64ToFloat::IsInitialized() const {
  return true;
}

void VectorMapInt64ToFloat::InternalSwap(VectorMapInt64ToFloat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.v_.InternalSwap(&other->_impl_.v_);
}

std::string VectorMapInt64ToFloat::GetTypeName() const {
  return "onnxruntime.proto.VectorMapInt64ToFloat";
}


// ===================================================================

class TraditionalMLData::_Internal {
 public:
  using HasBits = decltype(std::declval<TraditionalMLData>()._impl_._has_bits_);
  static const ::onnxruntime::proto::MapStringToString& map_string_to_string(const TraditionalMLData* msg);
  static const ::onnxruntime::proto::MapStringToInt64& map_string_to_int64(const TraditionalMLData* msg);
  static const ::onnxruntime::proto::MapStringToFloat& map_string_to_float(const TraditionalMLData* msg);
  static const ::onnxruntime::proto::MapStringToDouble& map_string_to_double(const TraditionalMLData* msg);
  static const ::onnxruntime::proto::MapInt64ToString& map_int64_to_string(const TraditionalMLData* msg);
  static const ::onnxruntime::proto::MapInt64ToInt64& map_int64_to_int64(const TraditionalMLData* msg);
  static const ::onnxruntime::proto::MapInt64ToFloat& map_int64_to_float(const TraditionalMLData* msg);
  static const ::onnxruntime::proto::MapInt64ToDouble& map_int64_to_double(const TraditionalMLData* msg);
  static const ::onnxruntime::proto::VectorString& vector_string(const TraditionalMLData* msg);
  static const ::onnxruntime::proto::VectorFloat& vector_float(const TraditionalMLData* msg);
  static const ::onnxruntime::proto::VectorInt64& vector_int64(const TraditionalMLData* msg);
  static const ::onnxruntime::proto::VectorDouble& vector_double(const TraditionalMLData* msg);
  static const ::onnxruntime::proto::VectorMapStringToFloat& vector_map_string_to_float(const TraditionalMLData* msg);
  static const ::onnxruntime::proto::VectorMapInt64ToFloat& vector_map_int64_to_float(const TraditionalMLData* msg);
  static const ::onnx::TensorProto& tensor(const TraditionalMLData* msg);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_debug_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::onnxruntime::proto::MapStringToString&
TraditionalMLData::_Internal::map_string_to_string(const TraditionalMLData* msg) {
  return *msg->_impl_.values_.map_string_to_string_;
}
const ::onnxruntime::proto::MapStringToInt64&
TraditionalMLData::_Internal::map_string_to_int64(const TraditionalMLData* msg) {
  return *msg->_impl_.values_.map_string_to_int64_;
}
const ::onnxruntime::proto::MapStringToFloat&
TraditionalMLData::_Internal::map_string_to_float(const TraditionalMLData* msg) {
  return *msg->_impl_.values_.map_string_to_float_;
}
const ::onnxruntime::proto::MapStringToDouble&
TraditionalMLData::_Internal::map_string_to_double(const TraditionalMLData* msg) {
  return *msg->_impl_.values_.map_string_to_double_;
}
const ::onnxruntime::proto::MapInt64ToString&
TraditionalMLData::_Internal::map_int64_to_string(const TraditionalMLData* msg) {
  return *msg->_impl_.values_.map_int64_to_string_;
}
const ::onnxruntime::proto::MapInt64ToInt64&
TraditionalMLData::_Internal::map_int64_to_int64(const TraditionalMLData* msg) {
  return *msg->_impl_.values_.map_int64_to_int64_;
}
const ::onnxruntime::proto::MapInt64ToFloat&
TraditionalMLData::_Internal::map_int64_to_float(const TraditionalMLData* msg) {
  return *msg->_impl_.values_.map_int64_to_float_;
}
const ::onnxruntime::proto::MapInt64ToDouble&
TraditionalMLData::_Internal::map_int64_to_double(const TraditionalMLData* msg) {
  return *msg->_impl_.values_.map_int64_to_double_;
}
const ::onnxruntime::proto::VectorString&
TraditionalMLData::_Internal::vector_string(const TraditionalMLData* msg) {
  return *msg->_impl_.values_.vector_string_;
}
const ::onnxruntime::proto::VectorFloat&
TraditionalMLData::_Internal::vector_float(const TraditionalMLData* msg) {
  return *msg->_impl_.values_.vector_float_;
}
const ::onnxruntime::proto::VectorInt64&
TraditionalMLData::_Internal::vector_int64(const TraditionalMLData* msg) {
  return *msg->_impl_.values_.vector_int64_;
}
const ::onnxruntime::proto::VectorDouble&
TraditionalMLData::_Internal::vector_double(const TraditionalMLData* msg) {
  return *msg->_impl_.values_.vector_double_;
}
const ::onnxruntime::proto::VectorMapStringToFloat&
TraditionalMLData::_Internal::vector_map_string_to_float(const TraditionalMLData* msg) {
  return *msg->_impl_.values_.vector_map_string_to_float_;
}
const ::onnxruntime::proto::VectorMapInt64ToFloat&
TraditionalMLData::_Internal::vector_map_int64_to_float(const TraditionalMLData* msg) {
  return *msg->_impl_.values_.vector_map_int64_to_float_;
}
const ::onnx::TensorProto&
TraditionalMLData::_Internal::tensor(const TraditionalMLData* msg) {
  return *msg->_impl_.values_.tensor_;
}
void TraditionalMLData::set_allocated_map_string_to_string(::onnxruntime::proto::MapStringToString* map_string_to_string) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_values();
  if (map_string_to_string) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map_string_to_string);
    if (message_arena != submessage_arena) {
      map_string_to_string = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map_string_to_string, submessage_arena);
    }
    set_has_map_string_to_string();
    _impl_.values_.map_string_to_string_ = map_string_to_string;
  }
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.map_string_to_string)
}
void TraditionalMLData::set_allocated_map_string_to_int64(::onnxruntime::proto::MapStringToInt64* map_string_to_int64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_values();
  if (map_string_to_int64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map_string_to_int64);
    if (message_arena != submessage_arena) {
      map_string_to_int64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map_string_to_int64, submessage_arena);
    }
    set_has_map_string_to_int64();
    _impl_.values_.map_string_to_int64_ = map_string_to_int64;
  }
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.map_string_to_int64)
}
void TraditionalMLData::set_allocated_map_string_to_float(::onnxruntime::proto::MapStringToFloat* map_string_to_float) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_values();
  if (map_string_to_float) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map_string_to_float);
    if (message_arena != submessage_arena) {
      map_string_to_float = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map_string_to_float, submessage_arena);
    }
    set_has_map_string_to_float();
    _impl_.values_.map_string_to_float_ = map_string_to_float;
  }
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.map_string_to_float)
}
void TraditionalMLData::set_allocated_map_string_to_double(::onnxruntime::proto::MapStringToDouble* map_string_to_double) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_values();
  if (map_string_to_double) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map_string_to_double);
    if (message_arena != submessage_arena) {
      map_string_to_double = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map_string_to_double, submessage_arena);
    }
    set_has_map_string_to_double();
    _impl_.values_.map_string_to_double_ = map_string_to_double;
  }
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.map_string_to_double)
}
void TraditionalMLData::set_allocated_map_int64_to_string(::onnxruntime::proto::MapInt64ToString* map_int64_to_string) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_values();
  if (map_int64_to_string) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map_int64_to_string);
    if (message_arena != submessage_arena) {
      map_int64_to_string = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map_int64_to_string, submessage_arena);
    }
    set_has_map_int64_to_string();
    _impl_.values_.map_int64_to_string_ = map_int64_to_string;
  }
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.map_int64_to_string)
}
void TraditionalMLData::set_allocated_map_int64_to_int64(::onnxruntime::proto::MapInt64ToInt64* map_int64_to_int64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_values();
  if (map_int64_to_int64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map_int64_to_int64);
    if (message_arena != submessage_arena) {
      map_int64_to_int64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map_int64_to_int64, submessage_arena);
    }
    set_has_map_int64_to_int64();
    _impl_.values_.map_int64_to_int64_ = map_int64_to_int64;
  }
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.map_int64_to_int64)
}
void TraditionalMLData::set_allocated_map_int64_to_float(::onnxruntime::proto::MapInt64ToFloat* map_int64_to_float) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_values();
  if (map_int64_to_float) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map_int64_to_float);
    if (message_arena != submessage_arena) {
      map_int64_to_float = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map_int64_to_float, submessage_arena);
    }
    set_has_map_int64_to_float();
    _impl_.values_.map_int64_to_float_ = map_int64_to_float;
  }
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.map_int64_to_float)
}
void TraditionalMLData::set_allocated_map_int64_to_double(::onnxruntime::proto::MapInt64ToDouble* map_int64_to_double) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_values();
  if (map_int64_to_double) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map_int64_to_double);
    if (message_arena != submessage_arena) {
      map_int64_to_double = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map_int64_to_double, submessage_arena);
    }
    set_has_map_int64_to_double();
    _impl_.values_.map_int64_to_double_ = map_int64_to_double;
  }
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.map_int64_to_double)
}
void TraditionalMLData::set_allocated_vector_string(::onnxruntime::proto::VectorString* vector_string) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_values();
  if (vector_string) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vector_string);
    if (message_arena != submessage_arena) {
      vector_string = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vector_string, submessage_arena);
    }
    set_has_vector_string();
    _impl_.values_.vector_string_ = vector_string;
  }
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.vector_string)
}
void TraditionalMLData::set_allocated_vector_float(::onnxruntime::proto::VectorFloat* vector_float) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_values();
  if (vector_float) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vector_float);
    if (message_arena != submessage_arena) {
      vector_float = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vector_float, submessage_arena);
    }
    set_has_vector_float();
    _impl_.values_.vector_float_ = vector_float;
  }
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.vector_float)
}
void TraditionalMLData::set_allocated_vector_int64(::onnxruntime::proto::VectorInt64* vector_int64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_values();
  if (vector_int64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vector_int64);
    if (message_arena != submessage_arena) {
      vector_int64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vector_int64, submessage_arena);
    }
    set_has_vector_int64();
    _impl_.values_.vector_int64_ = vector_int64;
  }
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.vector_int64)
}
void TraditionalMLData::set_allocated_vector_double(::onnxruntime::proto::VectorDouble* vector_double) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_values();
  if (vector_double) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vector_double);
    if (message_arena != submessage_arena) {
      vector_double = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vector_double, submessage_arena);
    }
    set_has_vector_double();
    _impl_.values_.vector_double_ = vector_double;
  }
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.vector_double)
}
void TraditionalMLData::set_allocated_vector_map_string_to_float(::onnxruntime::proto::VectorMapStringToFloat* vector_map_string_to_float) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_values();
  if (vector_map_string_to_float) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vector_map_string_to_float);
    if (message_arena != submessage_arena) {
      vector_map_string_to_float = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vector_map_string_to_float, submessage_arena);
    }
    set_has_vector_map_string_to_float();
    _impl_.values_.vector_map_string_to_float_ = vector_map_string_to_float;
  }
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.vector_map_string_to_float)
}
void TraditionalMLData::set_allocated_vector_map_int64_to_float(::onnxruntime::proto::VectorMapInt64ToFloat* vector_map_int64_to_float) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_values();
  if (vector_map_int64_to_float) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vector_map_int64_to_float);
    if (message_arena != submessage_arena) {
      vector_map_int64_to_float = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vector_map_int64_to_float, submessage_arena);
    }
    set_has_vector_map_int64_to_float();
    _impl_.values_.vector_map_int64_to_float_ = vector_map_int64_to_float;
  }
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.vector_map_int64_to_float)
}
void TraditionalMLData::set_allocated_tensor(::onnx::TensorProto* tensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_values();
  if (tensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tensor));
    if (message_arena != submessage_arena) {
      tensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tensor, submessage_arena);
    }
    set_has_tensor();
    _impl_.values_.tensor_ = tensor;
  }
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.tensor)
}
void TraditionalMLData::clear_tensor() {
  if (_internal_has_tensor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.values_.tensor_;
    }
    clear_has_values();
  }
}
TraditionalMLData::TraditionalMLData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.TraditionalMLData)
}
TraditionalMLData::TraditionalMLData(const TraditionalMLData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TraditionalMLData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.debug_info_){}
    , decltype(_impl_.values_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.debug_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.debug_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_debug_info()) {
    _this->_impl_.debug_info_.Set(from._internal_debug_info(), 
      _this->GetArenaForAllocation());
  }
  clear_has_values();
  switch (from.values_case()) {
    case kMapStringToString: {
      _this->_internal_mutable_map_string_to_string()->::onnxruntime::proto::MapStringToString::MergeFrom(
          from._internal_map_string_to_string());
      break;
    }
    case kMapStringToInt64: {
      _this->_internal_mutable_map_string_to_int64()->::onnxruntime::proto::MapStringToInt64::MergeFrom(
          from._internal_map_string_to_int64());
      break;
    }
    case kMapStringToFloat: {
      _this->_internal_mutable_map_string_to_float()->::onnxruntime::proto::MapStringToFloat::MergeFrom(
          from._internal_map_string_to_float());
      break;
    }
    case kMapStringToDouble: {
      _this->_internal_mutable_map_string_to_double()->::onnxruntime::proto::MapStringToDouble::MergeFrom(
          from._internal_map_string_to_double());
      break;
    }
    case kMapInt64ToString: {
      _this->_internal_mutable_map_int64_to_string()->::onnxruntime::proto::MapInt64ToString::MergeFrom(
          from._internal_map_int64_to_string());
      break;
    }
    case kMapInt64ToInt64: {
      _this->_internal_mutable_map_int64_to_int64()->::onnxruntime::proto::MapInt64ToInt64::MergeFrom(
          from._internal_map_int64_to_int64());
      break;
    }
    case kMapInt64ToFloat: {
      _this->_internal_mutable_map_int64_to_float()->::onnxruntime::proto::MapInt64ToFloat::MergeFrom(
          from._internal_map_int64_to_float());
      break;
    }
    case kMapInt64ToDouble: {
      _this->_internal_mutable_map_int64_to_double()->::onnxruntime::proto::MapInt64ToDouble::MergeFrom(
          from._internal_map_int64_to_double());
      break;
    }
    case kVectorString: {
      _this->_internal_mutable_vector_string()->::onnxruntime::proto::VectorString::MergeFrom(
          from._internal_vector_string());
      break;
    }
    case kVectorFloat: {
      _this->_internal_mutable_vector_float()->::onnxruntime::proto::VectorFloat::MergeFrom(
          from._internal_vector_float());
      break;
    }
    case kVectorInt64: {
      _this->_internal_mutable_vector_int64()->::onnxruntime::proto::VectorInt64::MergeFrom(
          from._internal_vector_int64());
      break;
    }
    case kVectorDouble: {
      _this->_internal_mutable_vector_double()->::onnxruntime::proto::VectorDouble::MergeFrom(
          from._internal_vector_double());
      break;
    }
    case kVectorMapStringToFloat: {
      _this->_internal_mutable_vector_map_string_to_float()->::onnxruntime::proto::VectorMapStringToFloat::MergeFrom(
          from._internal_vector_map_string_to_float());
      break;
    }
    case kVectorMapInt64ToFloat: {
      _this->_internal_mutable_vector_map_int64_to_float()->::onnxruntime::proto::VectorMapInt64ToFloat::MergeFrom(
          from._internal_vector_map_int64_to_float());
      break;
    }
    case kTensor: {
      _this->_internal_mutable_tensor()->::onnx::TensorProto::MergeFrom(
          from._internal_tensor());
      break;
    }
    case VALUES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.TraditionalMLData)
}

inline void TraditionalMLData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.debug_info_){}
    , decltype(_impl_.values_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.debug_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.debug_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_values();
}

TraditionalMLData::~TraditionalMLData() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.TraditionalMLData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TraditionalMLData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.debug_info_.Destroy();
  if (has_values()) {
    clear_values();
  }
}

void TraditionalMLData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TraditionalMLData::clear_values() {
// @@protoc_insertion_point(one_of_clear_start:onnxruntime.proto.TraditionalMLData)
  switch (values_case()) {
    case kMapStringToString: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.values_.map_string_to_string_;
      }
      break;
    }
    case kMapStringToInt64: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.values_.map_string_to_int64_;
      }
      break;
    }
    case kMapStringToFloat: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.values_.map_string_to_float_;
      }
      break;
    }
    case kMapStringToDouble: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.values_.map_string_to_double_;
      }
      break;
    }
    case kMapInt64ToString: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.values_.map_int64_to_string_;
      }
      break;
    }
    case kMapInt64ToInt64: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.values_.map_int64_to_int64_;
      }
      break;
    }
    case kMapInt64ToFloat: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.values_.map_int64_to_float_;
      }
      break;
    }
    case kMapInt64ToDouble: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.values_.map_int64_to_double_;
      }
      break;
    }
    case kVectorString: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.values_.vector_string_;
      }
      break;
    }
    case kVectorFloat: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.values_.vector_float_;
      }
      break;
    }
    case kVectorInt64: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.values_.vector_int64_;
      }
      break;
    }
    case kVectorDouble: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.values_.vector_double_;
      }
      break;
    }
    case kVectorMapStringToFloat: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.values_.vector_map_string_to_float_;
      }
      break;
    }
    case kVectorMapInt64ToFloat: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.values_.vector_map_int64_to_float_;
      }
      break;
    }
    case kTensor: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.values_.tensor_;
      }
      break;
    }
    case VALUES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VALUES_NOT_SET;
}


void TraditionalMLData::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.TraditionalMLData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.debug_info_.ClearNonDefaultToEmpty();
    }
  }
  clear_values();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TraditionalMLData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .onnxruntime.proto.MapStringToString map_string_to_string = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_map_string_to_string(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .onnxruntime.proto.MapStringToInt64 map_string_to_int64 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_map_string_to_int64(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .onnxruntime.proto.MapStringToFloat map_string_to_float = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_map_string_to_float(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .onnxruntime.proto.MapStringToDouble map_string_to_double = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_map_string_to_double(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .onnxruntime.proto.MapInt64ToString map_int64_to_string = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_map_int64_to_string(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .onnxruntime.proto.MapInt64ToInt64 map_int64_to_int64 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_map_int64_to_int64(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .onnxruntime.proto.MapInt64ToFloat map_int64_to_float = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_map_int64_to_float(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .onnxruntime.proto.MapInt64ToDouble map_int64_to_double = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_map_int64_to_double(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .onnxruntime.proto.VectorString vector_string = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_vector_string(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .onnxruntime.proto.VectorFloat vector_float = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_vector_float(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .onnxruntime.proto.VectorInt64 vector_int64 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_vector_int64(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .onnxruntime.proto.VectorDouble vector_double = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_vector_double(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .onnxruntime.proto.VectorMapStringToFloat vector_map_string_to_float = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_vector_map_string_to_float(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .onnxruntime.proto.VectorMapInt64ToFloat vector_map_int64_to_float = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_vector_map_int64_to_float(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .onnx.TensorProto tensor = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_tensor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string debug_info = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_debug_info();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TraditionalMLData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.TraditionalMLData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (values_case()) {
    case kMapStringToString: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::map_string_to_string(this),
          _Internal::map_string_to_string(this).GetCachedSize(), target, stream);
      break;
    }
    case kMapStringToInt64: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::map_string_to_int64(this),
          _Internal::map_string_to_int64(this).GetCachedSize(), target, stream);
      break;
    }
    case kMapStringToFloat: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::map_string_to_float(this),
          _Internal::map_string_to_float(this).GetCachedSize(), target, stream);
      break;
    }
    case kMapStringToDouble: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::map_string_to_double(this),
          _Internal::map_string_to_double(this).GetCachedSize(), target, stream);
      break;
    }
    case kMapInt64ToString: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::map_int64_to_string(this),
          _Internal::map_int64_to_string(this).GetCachedSize(), target, stream);
      break;
    }
    case kMapInt64ToInt64: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::map_int64_to_int64(this),
          _Internal::map_int64_to_int64(this).GetCachedSize(), target, stream);
      break;
    }
    case kMapInt64ToFloat: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::map_int64_to_float(this),
          _Internal::map_int64_to_float(this).GetCachedSize(), target, stream);
      break;
    }
    case kMapInt64ToDouble: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::map_int64_to_double(this),
          _Internal::map_int64_to_double(this).GetCachedSize(), target, stream);
      break;
    }
    case kVectorString: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::vector_string(this),
          _Internal::vector_string(this).GetCachedSize(), target, stream);
      break;
    }
    case kVectorFloat: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::vector_float(this),
          _Internal::vector_float(this).GetCachedSize(), target, stream);
      break;
    }
    case kVectorInt64: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::vector_int64(this),
          _Internal::vector_int64(this).GetCachedSize(), target, stream);
      break;
    }
    case kVectorDouble: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::vector_double(this),
          _Internal::vector_double(this).GetCachedSize(), target, stream);
      break;
    }
    case kVectorMapStringToFloat: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::vector_map_string_to_float(this),
          _Internal::vector_map_string_to_float(this).GetCachedSize(), target, stream);
      break;
    }
    case kVectorMapInt64ToFloat: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, _Internal::vector_map_int64_to_float(this),
          _Internal::vector_map_int64_to_float(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 15;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_name(), target);
  }

  // .onnx.TensorProto tensor = 16;
  if (_internal_has_tensor()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::tensor(this),
        _Internal::tensor(this).GetCachedSize(), target, stream);
  }

  // optional string debug_info = 17;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_debug_info(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.TraditionalMLData)
  return target;
}

size_t TraditionalMLData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.TraditionalMLData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 15;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string debug_info = 17;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_debug_info());
    }

  }
  switch (values_case()) {
    // .onnxruntime.proto.MapStringToString map_string_to_string = 1;
    case kMapStringToString: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_.map_string_to_string_);
      break;
    }
    // .onnxruntime.proto.MapStringToInt64 map_string_to_int64 = 2;
    case kMapStringToInt64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_.map_string_to_int64_);
      break;
    }
    // .onnxruntime.proto.MapStringToFloat map_string_to_float = 3;
    case kMapStringToFloat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_.map_string_to_float_);
      break;
    }
    // .onnxruntime.proto.MapStringToDouble map_string_to_double = 4;
    case kMapStringToDouble: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_.map_string_to_double_);
      break;
    }
    // .onnxruntime.proto.MapInt64ToString map_int64_to_string = 5;
    case kMapInt64ToString: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_.map_int64_to_string_);
      break;
    }
    // .onnxruntime.proto.MapInt64ToInt64 map_int64_to_int64 = 6;
    case kMapInt64ToInt64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_.map_int64_to_int64_);
      break;
    }
    // .onnxruntime.proto.MapInt64ToFloat map_int64_to_float = 7;
    case kMapInt64ToFloat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_.map_int64_to_float_);
      break;
    }
    // .onnxruntime.proto.MapInt64ToDouble map_int64_to_double = 8;
    case kMapInt64ToDouble: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_.map_int64_to_double_);
      break;
    }
    // .onnxruntime.proto.VectorString vector_string = 9;
    case kVectorString: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_.vector_string_);
      break;
    }
    // .onnxruntime.proto.VectorFloat vector_float = 10;
    case kVectorFloat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_.vector_float_);
      break;
    }
    // .onnxruntime.proto.VectorInt64 vector_int64 = 11;
    case kVectorInt64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_.vector_int64_);
      break;
    }
    // .onnxruntime.proto.VectorDouble vector_double = 12;
    case kVectorDouble: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_.vector_double_);
      break;
    }
    // .onnxruntime.proto.VectorMapStringToFloat vector_map_string_to_float = 13;
    case kVectorMapStringToFloat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_.vector_map_string_to_float_);
      break;
    }
    // .onnxruntime.proto.VectorMapInt64ToFloat vector_map_int64_to_float = 14;
    case kVectorMapInt64ToFloat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_.vector_map_int64_to_float_);
      break;
    }
    // .onnx.TensorProto tensor = 16;
    case kTensor: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.values_.tensor_);
      break;
    }
    case VALUES_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TraditionalMLData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TraditionalMLData*>(
      &from));
}

void TraditionalMLData::MergeFrom(const TraditionalMLData& from) {
  TraditionalMLData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.TraditionalMLData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_debug_info(from._internal_debug_info());
    }
  }
  switch (from.values_case()) {
    case kMapStringToString: {
      _this->_internal_mutable_map_string_to_string()->::onnxruntime::proto::MapStringToString::MergeFrom(
          from._internal_map_string_to_string());
      break;
    }
    case kMapStringToInt64: {
      _this->_internal_mutable_map_string_to_int64()->::onnxruntime::proto::MapStringToInt64::MergeFrom(
          from._internal_map_string_to_int64());
      break;
    }
    case kMapStringToFloat: {
      _this->_internal_mutable_map_string_to_float()->::onnxruntime::proto::MapStringToFloat::MergeFrom(
          from._internal_map_string_to_float());
      break;
    }
    case kMapStringToDouble: {
      _this->_internal_mutable_map_string_to_double()->::onnxruntime::proto::MapStringToDouble::MergeFrom(
          from._internal_map_string_to_double());
      break;
    }
    case kMapInt64ToString: {
      _this->_internal_mutable_map_int64_to_string()->::onnxruntime::proto::MapInt64ToString::MergeFrom(
          from._internal_map_int64_to_string());
      break;
    }
    case kMapInt64ToInt64: {
      _this->_internal_mutable_map_int64_to_int64()->::onnxruntime::proto::MapInt64ToInt64::MergeFrom(
          from._internal_map_int64_to_int64());
      break;
    }
    case kMapInt64ToFloat: {
      _this->_internal_mutable_map_int64_to_float()->::onnxruntime::proto::MapInt64ToFloat::MergeFrom(
          from._internal_map_int64_to_float());
      break;
    }
    case kMapInt64ToDouble: {
      _this->_internal_mutable_map_int64_to_double()->::onnxruntime::proto::MapInt64ToDouble::MergeFrom(
          from._internal_map_int64_to_double());
      break;
    }
    case kVectorString: {
      _this->_internal_mutable_vector_string()->::onnxruntime::proto::VectorString::MergeFrom(
          from._internal_vector_string());
      break;
    }
    case kVectorFloat: {
      _this->_internal_mutable_vector_float()->::onnxruntime::proto::VectorFloat::MergeFrom(
          from._internal_vector_float());
      break;
    }
    case kVectorInt64: {
      _this->_internal_mutable_vector_int64()->::onnxruntime::proto::VectorInt64::MergeFrom(
          from._internal_vector_int64());
      break;
    }
    case kVectorDouble: {
      _this->_internal_mutable_vector_double()->::onnxruntime::proto::VectorDouble::MergeFrom(
          from._internal_vector_double());
      break;
    }
    case kVectorMapStringToFloat: {
      _this->_internal_mutable_vector_map_string_to_float()->::onnxruntime::proto::VectorMapStringToFloat::MergeFrom(
          from._internal_vector_map_string_to_float());
      break;
    }
    case kVectorMapInt64ToFloat: {
      _this->_internal_mutable_vector_map_int64_to_float()->::onnxruntime::proto::VectorMapInt64ToFloat::MergeFrom(
          from._internal_vector_map_int64_to_float());
      break;
    }
    case kTensor: {
      _this->_internal_mutable_tensor()->::onnx::TensorProto::MergeFrom(
          from._internal_tensor());
      break;
    }
    case VALUES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TraditionalMLData::CopyFrom(const TraditionalMLData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.TraditionalMLData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraditionalMLData::IsInitialized() const {
  return true;
}

void TraditionalMLData::InternalSwap(TraditionalMLData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.debug_info_, lhs_arena,
      &other->_impl_.debug_info_, rhs_arena
  );
  swap(_impl_.values_, other->_impl_.values_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string TraditionalMLData::GetTypeName() const {
  return "onnxruntime.proto.TraditionalMLData";
}


// ===================================================================

class TestCaseConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<TestCaseConfig>()._impl_._has_bits_);
  static void set_has_per_sample_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_relative_per_sample_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_post_processing(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

TestCaseConfig::TestCaseConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:onnxruntime.proto.TestCaseConfig)
}
TestCaseConfig::TestCaseConfig(const TestCaseConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TestCaseConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.per_sample_tolerance_){}
    , decltype(_impl_.relative_per_sample_tolerance_){}
    , decltype(_impl_.post_processing_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.per_sample_tolerance_, &from._impl_.per_sample_tolerance_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.post_processing_) -
    reinterpret_cast<char*>(&_impl_.per_sample_tolerance_)) + sizeof(_impl_.post_processing_));
  // @@protoc_insertion_point(copy_constructor:onnxruntime.proto.TestCaseConfig)
}

inline void TestCaseConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.per_sample_tolerance_){0}
    , decltype(_impl_.relative_per_sample_tolerance_){0}
    , decltype(_impl_.post_processing_){false}
  };
}

TestCaseConfig::~TestCaseConfig() {
  // @@protoc_insertion_point(destructor:onnxruntime.proto.TestCaseConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TestCaseConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TestCaseConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TestCaseConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:onnxruntime.proto.TestCaseConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.per_sample_tolerance_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.post_processing_) -
        reinterpret_cast<char*>(&_impl_.per_sample_tolerance_)) + sizeof(_impl_.post_processing_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TestCaseConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double per_sample_tolerance = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_per_sample_tolerance(&has_bits);
          _impl_.per_sample_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double relative_per_sample_tolerance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_relative_per_sample_tolerance(&has_bits);
          _impl_.relative_per_sample_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool post_processing = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_post_processing(&has_bits);
          _impl_.post_processing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TestCaseConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:onnxruntime.proto.TestCaseConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double per_sample_tolerance = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_per_sample_tolerance(), target);
  }

  // optional double relative_per_sample_tolerance = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_relative_per_sample_tolerance(), target);
  }

  // optional bool post_processing = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_post_processing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:onnxruntime.proto.TestCaseConfig)
  return target;
}

size_t TestCaseConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:onnxruntime.proto.TestCaseConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double per_sample_tolerance = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double relative_per_sample_tolerance = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional bool post_processing = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TestCaseConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TestCaseConfig*>(
      &from));
}

void TestCaseConfig::MergeFrom(const TestCaseConfig& from) {
  TestCaseConfig* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:onnxruntime.proto.TestCaseConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.per_sample_tolerance_ = from._impl_.per_sample_tolerance_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.relative_per_sample_tolerance_ = from._impl_.relative_per_sample_tolerance_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.post_processing_ = from._impl_.post_processing_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TestCaseConfig::CopyFrom(const TestCaseConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:onnxruntime.proto.TestCaseConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TestCaseConfig::IsInitialized() const {
  return true;
}

void TestCaseConfig::InternalSwap(TestCaseConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TestCaseConfig, _impl_.post_processing_)
      + sizeof(TestCaseConfig::_impl_.post_processing_)
      - PROTOBUF_FIELD_OFFSET(TestCaseConfig, _impl_.per_sample_tolerance_)>(
          reinterpret_cast<char*>(&_impl_.per_sample_tolerance_),
          reinterpret_cast<char*>(&other->_impl_.per_sample_tolerance_));
}

std::string TestCaseConfig::GetTypeName() const {
  return "onnxruntime.proto.TestCaseConfig";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace onnxruntime
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapStringToString_VEntry_DoNotUse*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapStringToString_VEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapStringToString_VEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapStringToString*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapStringToString >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapStringToString >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapStringToInt64_VEntry_DoNotUse*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapStringToInt64_VEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapStringToInt64_VEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapStringToInt64*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapStringToInt64 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapStringToInt64 >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapStringToDouble_VEntry_DoNotUse*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapStringToDouble_VEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapStringToDouble_VEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapStringToDouble*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapStringToDouble >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapStringToDouble >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapStringToFloat_VEntry_DoNotUse*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapStringToFloat_VEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapStringToFloat_VEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapStringToFloat*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapStringToFloat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapStringToFloat >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapInt64ToString_VEntry_DoNotUse*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapInt64ToString_VEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapInt64ToString_VEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapInt64ToString*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapInt64ToString >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapInt64ToString >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapInt64ToInt64_VEntry_DoNotUse*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapInt64ToInt64_VEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapInt64ToInt64_VEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapInt64ToInt64*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapInt64ToInt64 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapInt64ToInt64 >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapInt64ToFloat_VEntry_DoNotUse*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapInt64ToFloat_VEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapInt64ToFloat_VEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapInt64ToFloat*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapInt64ToFloat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapInt64ToFloat >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapInt64ToDouble_VEntry_DoNotUse*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapInt64ToDouble_VEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapInt64ToDouble_VEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::MapInt64ToDouble*
Arena::CreateMaybeMessage< ::onnxruntime::proto::MapInt64ToDouble >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::MapInt64ToDouble >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::VectorString*
Arena::CreateMaybeMessage< ::onnxruntime::proto::VectorString >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::VectorString >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::VectorFloat*
Arena::CreateMaybeMessage< ::onnxruntime::proto::VectorFloat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::VectorFloat >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::VectorInt64*
Arena::CreateMaybeMessage< ::onnxruntime::proto::VectorInt64 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::VectorInt64 >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::VectorDouble*
Arena::CreateMaybeMessage< ::onnxruntime::proto::VectorDouble >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::VectorDouble >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::VectorMapStringToFloat*
Arena::CreateMaybeMessage< ::onnxruntime::proto::VectorMapStringToFloat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::VectorMapStringToFloat >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::VectorMapInt64ToFloat*
Arena::CreateMaybeMessage< ::onnxruntime::proto::VectorMapInt64ToFloat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::VectorMapInt64ToFloat >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::TraditionalMLData*
Arena::CreateMaybeMessage< ::onnxruntime::proto::TraditionalMLData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::TraditionalMLData >(arena);
}
template<> PROTOBUF_NOINLINE ::onnxruntime::proto::TestCaseConfig*
Arena::CreateMaybeMessage< ::onnxruntime::proto::TestCaseConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::onnxruntime::proto::TestCaseConfig >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
